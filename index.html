<!DOCTYPE html>
<html>
    <body>
        <div id="root"></div>
    </body>
    <script src="https://unpkg.com/react@17.0.2/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@17.0.2/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel">
    // 컴포넌트의 첫 문자는 무조건 대문자여야 한다.
    // 그래야 JSX에서 해당 컴포넌트를 컴포넌트로 인식하고 해석할 수 있다.
    // 소문자로 하게 되면 일반 html 태그로 인식하게 된다.
    // props가 component가 전달받는 첫번째 인자이자 유일한 인자가 된다. 두번째 인자는 존재하지 않음
    // 모든 전달받은 prop값은 다 첫번째 인자(여기서는 props로 명명했으니) props에 들어간다.
    function Btn({text, changeValue}) {
        console.log(text +" was rendered");
        return (
            <button 
                onClick={changeValue}
                style={{
                    backgroundColor: "tomato",
                    color: "white",
                    padding: "10px 20px",
                    border: 0,
                    borderRadius: 10, 
                }}
            >
                {text}
            </button>
        )
    }
    
    // 부모 컴포넌트에서 state의 변경이 있으면, 자식 컴포넌트들은 모두 새로 rendering된다.
    // 그렇지만 이것을 막기 위해 React.memo() 함수 안에 state의 직접적인 변경이 없으면
    // render에서 제외할 컴포넌트를 지정하고, 그 컴포넌트로 사용하게 되면
    // 부모 컴포넌트에서 state의 변경이 있더라도 직접적인 state변경에 영향을 받지 않는
    // memo컴포넌트는 rendering 되지 않는다.
    // 이는 추후 앱 구동 속도와 같은 곳에 영향을 미칠 수 있는 사항이므로 기억해두면 좋다.
    const MemorizedBtn = React.memo(Btn);
    const App = () => {
        const [value, setValue] = React.useState("Save Changes");
        const changeValue = () => setValue("Revert Changes");
        return (
            <div>
                <MemorizedBtn text={value} changeValue={changeValue} />
                <MemorizedBtn text="Continue" />
            </div>
        );
    }
    const root = document.getElementById("root");
    ReactDOM.render(<App />, root);
    </script>
</html>